////////////////////
Licensed to Cloudera, Inc. under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  Cloudera, Inc. licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
////////////////////

=== Limiting Data Transfer Rate between Source-Sink pairs
WARNING: This feature is only available when using memory-backed store and not the zookeeper-backed store.

Flume has the ability to limit the rate of transfer of data between source-sink pairs.  
This is useful to divide the network bandwidth non-uniformly among different 
source-sink pairs based on the kind of logs they are transferring.  
Maybe you want some types of logs to be shipped at a faster rate that others, maybe you want to transfer logs at different rate at different times of the day.


Another situation where it is good to limit the rate of data transfer is when the network (or a collector) recovers after a failure.  
In this case the agents might have lot of data backed up to ship, so if there is no limit on the transfer rate, 
the agents can exhaust all the resources of the collector and make it even crash.  


In Flume a special sink-decorator called the +choke+ decorator can be used to limit the rate of transfer of data between source-sink pairs.
Each +choke+ decorator (simply called a +choke+) has to be assigned to a +choke-id+.  
Here is an example that uses a +choke+ with +choke-id+ "Cid" between a source and sink of a node.
----
node: source | { choke("Cid") => sink };
----

The +choke-ids+ are specific to a physical node, and before using a +choke+ with a certain +choke-id+ on +node+, 
one should register the +choke-id+ on the physical node containing the +node+.  
A +choke-id+ can be registered on a physical node using the +setChokeLimit+ command.  
When a +choke-id+ is registered, a rate limit (in KB/sec) has to be assigned to it.  
Here is an example to register a +choke-id+ "Cid" on a physical node +host+ with a limit 1000 KB/sec.
----
exec setChokeLimit host Cid 1000
----

NOTE: setChokeLimit can also be used to change the limit associated to a +choke-id+ at the run-time. 

The limit set on the +choke-id+ puts an upper bound on the rate at which the +chokes+ using that +choke-id+ can collectively transfer data.  
In the example above there is only one source-sink pair on the physical node +host+ that uses a +choke+ with +choke-id+ "Cid", so the rate of data transfer between that source-sink pair is limited to 1000 KB/sec. 

NOTE: For the purpose of rate limiting only the size of the event body is taken into account. 

The +choke+ decorator works as follows: when +append()+ is called on the sink to which the +choke+ 
is attached, the +append()+ call works normally if the amount of data transferred 
(during a small duration of time) is within the limits set on the +choke-id+ corresponding to the +choke+, 
if the limit has been reached then +append()+ is blocked for a small duration of time.


Let us take an example where multiple source-sink pairs are using the +chokes+ between them using 
the same +choke-id+.  Say both +node1+ and +node2+ are logical nodes on the same physical node +host+, 
and a +choke-id+ "Cid" with limit 1000KB/sec is registered on +host+.

----
node1: source1 | { choke("Cid") => sink1 };
node2: source2 | { choke("Cid") => sink2 };
----
In the above example as both +source1-sink1+ and +source2-sink2+ pairs are using +chokes+ with the same +choke-id+ "Cid", the total data going across these source-sink pairs collectively will be limited by 1000KB/sec. 
Flume does not guarantee in any way how this limit will be divided between the source-sink pairs, 
but it does guarantee that neither source-sink pair will starve.

NOTE: If multiple source-sink pairs on the same physical node use chokes having the same choke-id, 
then there is no guarantee how the rate limit will be divided between these source-sink pairs.

